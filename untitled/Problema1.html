<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>Problema 1</title>

</head>

<body>
<h1>Problema 1</h1>
<a href="/untitled/index.html">Projeto CP</a>
<a href="/untitled/Problema2.html">Problema 2</a>
<a href="/untitled/Problema3.html">Problema 3</a>
<a href="/untitled/Problema4.html">Problema 4</a>
  <p>
    <h3>Primeira Questão</h3>
    A primeira questão do problema 1 pede que se definam as funções outExpAr e recExpAr que são o
    "out" de ExpAr e o Funtor de ExpAr respetivamente.<br>
    É-nos facultado o "in" de ExpAr, o Funtor de base de ExpAr e também os tipos de ExpAr, BinOp e UnOp. <br>
    Sabe-se que out . in = id, então, baseados no que aprendemos nas aulas e em todas as propriedades presentes no formulário, resolvemos essa igualdade com vista em obter o out de ExpAr.
    (Mostrar cálculos no relatório). <br>
    Daqui temos a definição de outExpAr.
  <br>
  <br>
    A partir do funtor de base e segundo a lei 49 do formulário  temos que F f = B(id,f).
    Assim, conhecendo o Funtor de Base, tendo em conta a lei 49 e com a ajuda do diagrama, conclui-se
    que recExpAr f = baseExpAr id id id f f id f. <br>
    <h4>No terminal: </h4>
    <strong>quickCheck prop_in_out_idExpAr</strong>
  </p>
  <br>
  <p>
    <h3>Segunda Questão</h3>
    Na segunda questão é pedido que seja definido o gene do catamorfismo <em>eval_exp</em> que nos é facultado. <br>
    A partir do desenho do catamorfismo concluí-se que <em>g_eval_exp</em> recebe uma de 4 coisas: <br>
      <ul>
        <li>X</li>
          <ul>
            <li>Neste caso o valor de saída é o valor passado a eval_exp (atribuído a X)</li>
            <br>
          </ul>
        <li>N (Número)</li>
          <ul>
            <li>Aqui será devolvido o algarismo na expressão, ou seja, (Número)</li>
            <br>
          </ul>
        <li>BinOp op expAr expAr</li>
          <ul>
            <li>Neste caso op tanto pode ser Product como Sum
                No caso de ser Product o resultado será x * y e se for Sum é x + y</li>
            <br>
          </ul>
        <li>UnOp expAr</li>
          <ul>Caso seja Negate temos -x e se for E temos expd x</ul>
        <br>
      </ul>
    <h4>No terminal: </h4>
    <strong>quickCheck prop_sum_idr</strong> <br>
    <strong>quickCheck prop_sum_idl</strong> <br>
    <strong>quickCheck prop_product_idr</strong> <br>
    <strong>quickCheck prop_product_idl</strong> <br>
    <strong>quickCheck prop_e_id</strong> <br>
    <strong>quickCheck prop_negate_id</strong> <br>
    <strong>quickCheck double_negate</strong> <br>

  </p>
  <br>
  <p>
    <h3>Terceira Questão</h3>
      A terceira questão tem como objetivo otimizar o cálculo de uma expressão. <br>
      Isto é possível usando uma estratégia de <em>divide and conquer</em> que no que aprendemos se
      traduz num hilomorfismo. <br>
      <br>
      No que diz respeito à parte de <em>divide</em> (representada pelo anamorfismo) o grupo decidiu identificar operações de produto
      em que um dos membros fosse um 0 e ao encontrar iria injetar o 0. <br>
      Desta forma quando chegarmos à parte do <em>conquer</em> feita pelo catamorfismo
      estaremos a poupar um cálculo. <br>
      <br>
      Ilustração do gene do anamorfismo <em>clean</em>. <br>
      Ilustração do gene do catamorfismo <em>gopt</em>. <br>
      <br>

      <h4>No terminal: </h4>
      <strong>quickCheck prop_optimize_respects_semantics</strong>


  </p>
  <br>
  <p>
    <h3>Quarta Questão</h3>
      Nesta questão é suposto definir o gene do catamorfismo que ocorre em sd. <br>
      O objetivo é calcular a derivada de uma ExpAr. <br>
      Seguindo as regras dadas no enunciado e sabendo que para cada expressão é recebido um par (
      original,derivada) chegou-se ao resultado final. <br>
      Ilustração do gene <em>se_gen</em>. <br>
      <br>

      <h4>No terminal: </h4>
      <strong>quickCheck prop_const_rule</strong> <br>
      <strong>quickCheck prop_var_rule</strong> <br>
      <strong>quickCheck prop_sum_rule</strong> <br>
      <strong>quickCheck prop_product_rule</strong> <br>
      <strong>quickCheck prop_e_rule</strong> <br>
      <strong>quickCheck prop_negate_rule</strong> <br>

  </p>
  <br>

  <p>
    <h3>Quinta Questão</h3>
      Aqui o objetivo é definir o gene que ocorre na função <em>ad</em> que dada uma expressão e um ponto
      calcula o valor da sua derivada nesse ponto. <br>
      A diferença da questão 4 para a 5 é que agora estaremos a devolver o resultado do cálculo e
      não uma expressão. <br>
      Ilustração do gene <em>ad_gen</em>. <br>

      <h4>No terminal:</h4>
      <strong>quickCheck prop_congruent</strong>

  </p>

</body>
</html>
